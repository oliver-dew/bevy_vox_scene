mod components;
mod parse_model;
mod parse_scene;

use anyhow::anyhow;
use bevy::{
    asset::{io::Reader, AssetLoader, LoadContext},
    color::LinearRgba,
    log::info,
    math::Vec3,
    platform::collections::HashSet,
    scene::Scene,
};
use components::LayerInfo;
pub use components::{
    AnimationUpdate, VoxelAnimationFrame, VoxelAnimationPlayer, VoxelLayer, VoxelModelInstance,
};
use parse_scene::{find_model_names, parse_scene_graph};
use serde::{Deserialize, Serialize};
use thiserror::Error;

use crate::{
    model::{MaterialProperty, VoxelModel, VoxelPalette},
    VoxelContext, VoxelData, VoxelQueryable,
};

/// An asset loader capable of loading models in `.vox` files as [`bevy::scene::Scene`]s.
///
/// It converts Magica Voxel's left-handed Z-up space to bevy's right-handed Y-up space.
/// The meshes generated by this asset loader only use standard [`bevy::render::mesh::Mesh`] attributes for easier compatibility with shaders.
/// You can load multiple models from the same `.vox` file by appending `#{name}` to the asset loading path, where `{name}` corresponds to the object's name in the Magical Voxel world editor.
/// You can load unnamed models by appending `#model{no}` to the asset loading path, where `{no}` corresponds to the model index in the file. Note that this index is subject to change if you delete models in the Magica Voxel file.
pub(super) struct VoxSceneLoader {
    pub(super) global_settings: Option<VoxLoaderSettings>,
}

/// Settings for the VoxSceneLoader.
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct VoxLoaderSettings {
    /// The length of each side of a single voxel. Defaults to 1.0.
    pub voxel_size: f32,
    /// Whether the outer-most faces of the model should be meshed. Defaults to true. Set this to false if the outer faces of a
    /// model will never be visible, for instance if the model id part of a 3D tileset.
    pub mesh_outer_faces: bool,
    /// Amount that the vertex positions of the mesh will be offset described as unit of their size.
    /// Defaults to [`UnitOffset::CENTER`] the center of the model, as this is where MagicaVoxel places the origin in its world editor
    pub mesh_offset: UnitOffset,
    /// Multiplier for emissive strength. Defaults to 10.0.
    pub emission_strength: f32,
    /// Defaults to `true` to more accurately reflect the colours in Magica Voxel.
    pub uses_srgb: bool,
    /// Magica Voxel doesn't let you adjust the roughness for the default "diffuse" block type, so it can be adjusted with this setting. Defaults to 0.8.
    pub diffuse_roughness: f32,
    /// Set to `true` if you want to modify the voxel model after it has been spawned, `false` if the voxels will be immutable
    pub supports_remeshing: bool,
}

impl Default for VoxLoaderSettings {
    fn default() -> Self {
        Self {
            voxel_size: 1.0,
            mesh_outer_faces: true,
            mesh_offset: UnitOffset::CENTER,
            emission_strength: 20.0,
            uses_srgb: true,
            diffuse_roughness: 0.8,
            supports_remeshing: false,
        }
    }
}

/// An offset applied to the vertex positions of the mesh expressed as a unit of the mesh's size.
/// For a fully centered mesh, use [`UnitOffset::CENTER`]
/// For a mesh centred around it's base, use [`UnitOffset::CENTER_BASE`]
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct UnitOffset(pub(crate) Vec3);

impl UnitOffset {
    /// Vertex positions will not be offset at all, so that the origin will be the minimum of the model's AABB
    pub const ZERO: Self = UnitOffset(Vec3::ZERO);

    /// Offset representing the center of a model
    pub const CENTER: Self = UnitOffset(Vec3::splat(0.5));

    /// Offset representing the center base of a model
    pub const CENTER_BASE: Self = UnitOffset(Vec3::new(0.5, 0.0, 0.5));
}

#[derive(Error, Debug)]
pub enum VoxLoaderError {
    #[error(transparent)]
    InvalidAsset(#[from] anyhow::Error),
}

impl AssetLoader for VoxSceneLoader {
    type Asset = Scene;
    type Settings = VoxLoaderSettings;
    type Error = VoxLoaderError;

    async fn load(
        &self,
        reader: &mut dyn Reader,
        settings: &Self::Settings,
        load_context: &mut LoadContext<'_>,
    ) -> Result<Self::Asset, Self::Error> {
        let mut bytes = Vec::new();
        reader
            .read_to_end(&mut bytes)
            .await
            .map_err(|e| VoxLoaderError::InvalidAsset(anyhow!(e)))?;
        self.process_vox_file(&bytes, load_context, settings)
    }

    fn extensions(&self) -> &[&str] {
        &["vox"]
    }
}

impl VoxSceneLoader {
    fn process_vox_file<'a>(
        &self,
        bytes: &'a [u8],
        load_context: &'a mut LoadContext,
        settings: &'a VoxLoaderSettings,
    ) -> Result<Scene, VoxLoaderError> {
        let file = match dot_vox::load_bytes(bytes) {
            Ok(data) => data,
            Err(error) => return Err(VoxLoaderError::InvalidAsset(anyhow!(error))),
        };
        info!("Loading {}", load_context.asset_path());
        let settings = self.global_settings.clone().unwrap_or(settings.clone());

        // Palette
        let palette = VoxelPalette::from_data(
            &file,
            settings.diffuse_roughness,
            settings.emission_strength,
            settings.uses_srgb,
        );
        let translucent_material = palette.create_material_in_load_context(load_context);
        let opaque_material = load_context.labeled_asset_scope("material".to_string(), |_| {
            let mut opaque_material = translucent_material.clone();
            #[cfg(feature = "pbr_transmission_textures")]
            {
                opaque_material.specular_transmission_texture = None;
            }
            opaque_material.specular_transmission = 0.0;
            opaque_material
        });
        if palette.emission == MaterialProperty::VariesPerElement {
            load_context.labeled_asset_scope("material-no-emission".to_string(), |_| {
                let mut non_emissive = translucent_material.clone();
                non_emissive.emissive_texture = None;
                non_emissive.emissive = LinearRgba::BLACK;
                non_emissive
            });
        }

        // Scene graph
        let layers: Vec<LayerInfo> = file
            .layers
            .iter()
            .map(|layer| LayerInfo {
                name: layer.name(),
                is_hidden: layer.hidden(),
            })
            .collect();

        let model_count = file.models.len();
        let mut subassets: HashSet<String> = HashSet::default();
        let mut model_names: Vec<Option<String>> = vec![None; model_count];
        find_model_names(&mut model_names, &file.scenes, &file.scenes[0], None);

        // Models

        let models: Vec<VoxelModel> = model_names
            .iter()
            .zip(file.models)
            .enumerate()
            .map(|(index, (maybe_name, model))| {
                let name = maybe_name.clone().unwrap_or(format!("model-{}", index));
                let data = VoxelData::from_model(&model, settings.clone());
                let (visible_voxels, ior, has_mesh) =
                    data.visible_voxels(&palette.indices_of_refraction, &palette.density_for_voxel);
                let (cloud_voxels, has_cloud) = data.cloud_voxels(&palette.density_for_voxel);
                if has_mesh {
                    load_context.labeled_asset_scope(format!("{}@mesh", name), |_| {
                        crate::model::mesh::mesh_model(&visible_voxels, &data)
                    });

                    if let Some(ior) = ior {
                        load_context.labeled_asset_scope(format!("{}@material", name), |_| {
                            let mut material = translucent_material.clone();
                            material.ior = ior;
                            material.thickness = data.size().min_element() as f32;
                            material
                        });
                    } else {
                        load_context.labeled_asset_scope(format!("{}@material", name), |_| {
                            let mut opaque_material = translucent_material.clone();
                            #[cfg(feature = "pbr_transmission_textures")]
                            {
                                opaque_material.specular_transmission_texture = None;
                            }
                            opaque_material.specular_transmission = 0.0;
                            opaque_material
                        });
                    }
                }
                if has_cloud {
                    load_context.labeled_asset_scope(format!("{}@cloud-image", name), |_| {
                        crate::model::cloud::create_cloud_image(&cloud_voxels, &data)
                    });
                }
                let model = VoxelModel {
                    name: name.clone(),
                    data,
                    has_mesh,
                    has_cloud,
                };
                load_context.labeled_asset_scope(format!("{}@model", name), |_| model.clone());
                model
            })
            .collect();

        let transmissive_material = load_context
            .add_labeled_asset("material-transmissive".to_string(), translucent_material);
        load_context.add_labeled_asset(
            "voxel-context".to_string(),
            VoxelContext {
                palette,
                opaque_material,
                transmissive_material,
            },
        );
        let scene = parse_scene_graph(
            load_context,
            &file.scenes,
            &file.scenes[0],
            None,
            &models,
            &mut subassets,
            &layers,
            settings.voxel_size,
        );

        Ok(scene)
    }
}
